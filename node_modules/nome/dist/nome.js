'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Lill = _interopDefault(require('lill'));

var isFunction = function isFunction(func) {
	return typeof func === 'function';
};

function NoMe(method) {
	function NoMeWrapped() {
		var _this = this;

		var args = Array.prototype.slice.call(arguments); // eslint-disable-line prefer-rest-params

		var returnValue = isFunction(method) ? Function.prototype.apply.call(method, this, args) : undefined;

		var NoMe$loop = function NoMe$loop(_ref) {
			var cb = _ref.cb,
			    ctx = _ref.ctx;

			Function.prototype.apply.call(cb, ctx || _this, args);
		};

		Lill.each(NoMeWrapped, NoMe$loop);

		return returnValue;
	}

	NoMeWrapped.notify = NoMe$notify;
	NoMeWrapped.denotify = NoMe$denotify;

	Lill.attach(NoMeWrapped);

	return NoMeWrapped;
}

function NoMe$notify(cb, ctx) {
	if (!isFunction(cb)) {
		throw new TypeError('NoMe.notify expects function for notification');
	}
	var notifier = { cb: cb, ctx: ctx };
	Lill.add(this, notifier);
	return notifier;
}

function NoMe$denotify(notifier) {
	Lill.remove(this, notifier);
}

NoMe.is = function isNoMe(value) {
	return Boolean(isFunction(value) && value.notify === NoMe$notify);
};

var nome = Object.freeze(NoMe);

module.exports = nome;
